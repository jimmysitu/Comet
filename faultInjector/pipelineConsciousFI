#!/usr/bin/env python3

import subprocess, re, os, random, filecmp, argparse, colorama, collections, pickle, time, pdb, math
from multiprocessing import Pool
from functools import partial
import numpy as np

import FIRegInfo as ri  #register informations and useful functions

nBitPerInj = 3

PartialResult = collections.namedtuple('PartialResult', ['endType', 'cycle', 'runNumber'])

################################################################################
#               Injection support
################################################################################

#runs the simulator with the given workload and arguments
def executeSimulation(workload, arguments):
    devnull = open(os.devnull, 'w')
    runList = ['../cometFI.sim', '-f', workload]
    runList.extend(arguments)
    #print(' '.join(runList))
    #result = subprocess.run(['../cometFI.sim', '-f', workload] + arguments, stdout=subprocess.PIPE, stderr=devnull)
    result = subprocess.run(runList, stdout=subprocess.PIPE, stderr=devnull)
    devnull.close()
    return result.stdout.decode('unicode_escape')


#collect the golden sample data : execution cycle count, stdout and memory+register dump
def doGoldenRun(benchmarkPath, verbosity):
    startTime = time.time()
    runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/goldenSampleStdout', '-D', '/tmp/goldenSampleMemory'])
    elapsedTime = time.time() - startTime
    #get the cycle count
    cycles = re.findall('in (.*) cycles', runStdOut)
    cycles = int(cycles[0])
    if verbosity > 1:
        print("----------golden stdout----------")
        subprocess.call(['cat', '/tmp/goldenSampleStdout'])
    return cycles, elapsedTime


#injects a fault at the given cycle, checks the workload termination type and populate the result base
def doInjectionRun(runNumber, benchmarkPath, referenceCycles, patterns, verbosity):
    #compute the maximum cycle count
    maxAllowedCycles = 8*referenceCycles

    #pick a cycle
    injectionCycle = random.randint(0, referenceCycles)

    #select a zone to inject in
    place = ri.selectRegion()

    if place=='sequential': #choose a random FF and flip it
        #choose a register
        place = ri.selectRegister() #only place where the PC can be hit
        #select a random FF inside
        bitPositions = ri.getrandomBitsinRegister(place, 1)

    elif place == 'comb_other': #inject in one of the core ctrl FFs
        place = 'CoreCtrl'
        bitPositions = ri.getrandomBitsinRegister(place, 1)

    elif place == 'WriteBack':   #inject in the register file
        #see faultInjection.md for further details on the fault model
        #select a random register (can be the one selected in the WB stage)
        place = ri.selectRFRegister()
        #fill it with a random number of errors
        #bitPositions = ri.getrandomBitsinRegister(place, random.randint(1,31))
        bitPositions = ri.getrandomBitsinRegister(place, 1)

    #only inject 1 bit if a pipeline stage comb logic is hit
    else:
        bitPositions = ri.getrandomBitsinRegister(place, nBitPerInj)

    ''' USE THIS IF YOU WANT TO INJECT ERROR PATTERNS
    else:  #selected region is a pipeline stage's combinational logic
        bitPositions = ri.patternToBitPositions(ri.getPattern(place, patterns))   #select a pattern to inject
    '''

    if verbosity > 0:
        print("Injection cycle : " + str(injectionCycle) + ", place : " + place + ", bitPositions : " + ' ' + '"' + ' '.join(map(str, bitPositions)) + '"')
    #run the simulator
    placeId = ri.getRegisterID(place)
    #runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/injectionRunStdout', '-D', '/tmp/injectionRunMemory', '-I', str(maxAllowedCycles), str(injectionCycle), str(placeId), '"' + ' '.join(map(str, bitPositions)) + '"'])
    runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/injectionRunStdout_'+str(runNumber), '-D', '/tmp/injectionRunMemory_'+str(runNumber), '-I', str(maxAllowedCycles), str(injectionCycle), str(placeId), ' '.join(map(str, bitPositions))])
    #capture the end type
    endType = re.findall('EndType : (.*)', runStdOut)

    #declare the result dict
    resDict = {place : dict(dict())}

    #if the workload execution terminated without a crash or a hang
    if endType[0] == 'Normal':
        #check the output and the memory dump against the golden sample
        filecmp.clear_cache()   #really needed ?
        inISMSpace = not filecmp.cmp('/tmp/goldenSampleMemory', '/tmp/injectionRunMemory_'+str(runNumber), shallow=False)
        inAOMSpace = not filecmp.cmp('/tmp/goldenSampleStdout', '/tmp/injectionRunStdout_'+str(runNumber), shallow=False)

        #print('ISM : ' + str(inISMSpace))
        #print('AOM : ' + str(inAOMSpace))

        if (inISMSpace) and (inAOMSpace):
            endType[0] = 'ISM & AOM'
        elif (inISMSpace) and (not inAOMSpace):
            endType[0] = 'ISM'
        elif (not inISMSpace) and (inAOMSpace):
            endType[0] = 'AOM'
        else:
            endType[0] = 'Masked'

    if os.path.isfile('/tmp/injectionRunMemory_'+str(runNumber)):
        os.remove('/tmp/injectionRunMemory_'+str(runNumber))
    if os.path.isfile('/tmp/injectionRunStdout_'+str(runNumber)):
        os.remove('/tmp/injectionRunStdout_'+str(runNumber))

    if verbosity > 0:
        print("endType : " + endType[0])

    for bit in bitPositions:
        nt = PartialResult(endType[0], injectionCycle, runNumber)
        resDict[place][bit] = nt

    if verbosity > 1:
        print("Run output :")
        subprocess.call(['cat', '/tmp/injectionRunStdout'])
    if verbosity > 0:
        print("---------------------------------")

    return resDict


################################################################################
#               Results support
################################################################################

#sets up all the results data (creates an entry for each bit in the design and initializes it's stats)
def initResults(dic):
    for key in ri.getRegisterList():
        dic[key] = []
        for bit in range(ri.getRegisterWidth(key)):
            dic[key].append({}) #create a dict for each bit in the selected place
            dic[key][bit]["cycles"] =  []
            dic[key][bit]["runNumber"] = []
            dic[key][bit]["nbInj"] = 0  #init the selected bit's stats
            dic[key][bit]["Masked"] = 0
            dic[key][bit]["ISM"] = 0
            dic[key][bit]["AOM"] = 0
            dic[key][bit]["ISM & AOM"] = 0
            dic[key][bit]["Hang"] = 0
            dic[key][bit]["Crash"] = 0

def showFinalStats_bitwise(results):
    #go through the results base and collect the needed stats
    sumMasked = 0
    sumISM = 0
    sumAOM = 0
    sumISMAOM = 0
    sumHang = 0
    sumCrash = 0
    for key in ri.getRegisterList():
        for bit in range(ri.getRegisterWidth(key)):
            sumMasked += results[key][bit]["Masked"]
            sumISM += results[key][bit]["ISM"]
            sumAOM += results[key][bit]["AOM"]
            sumISMAOM += results[key][bit]["ISM & AOM"]
            sumHang += results[key][bit]["Hang"]
            sumCrash += results[key][bit]["Crash"]
    print("Masked : " + str(sumMasked))
    print("ISM : " + str(sumISM))
    print("AOM : " + str(sumAOM))
    print("ISM & AOM : " + str(sumISMAOM))
    print("Hang : " + str(sumHang))
    print("Crash : " + str(sumCrash))

def showFinalStats_runwise(results):
    #go through the results base and collect the needed stats
    place_counters = {}
    end_counters = {}

    for run in results:
        #log places
        if run[0] not in place_counters:
            place_counters[run[0]] = 1
        else:
            place_counters[run[0]] += 1
        #log outcomes
        if run[1] not in end_counters:
            end_counters[run[1]] = 1
        else:
            end_counters[run[1]] += 1

    #display the counters
    print('\nInjection spots :')
    for place in place_counters:
        print('{0} : {1}'.format(place, place_counters[place]))
    print('\nInjection results :')
    for end in end_counters:
        print('{0} : {1}'.format(end, end_counters[end]))


def saveResults(path, results_bitwise, results_runwise):
    if os.path.isdir(path):
        #output the results
        with open(path+'/bitwise.pkl', 'wb') as of:
            pickle.dump(results_bitwise, of)
        with open(path+'/runwise.pkl', 'wb') as of:
            pickle.dump(results_runwise, of)

    else: #path doesn't exist, create the directory and output the results
        try:
            os.mkdir(path)
        except OSError:
            print ("Output directory ({0}) creation has failed".format(path))
        with open(path+'/bitwise.pkl', 'wb') as of:
            pickle.dump(results_bitwise, of)
        with open(path+'/runwise.pkl', 'wb') as of:
            pickle.dump(results_runwise, of)

def getNumberOfNeededRuns(workloadCycles, numberOfInjectionPoints):
    N = workloadCycles*numberOfInjectionPoints
    div = 1+( ((0.01**2)*(N-1)) / (0.25*(3.0902**2)) )
    return math.ceil(N/div)



################################################################################
#               Main
################################################################################

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--nbInj", type=int, help="number of injections to perform")
    parser.add_argument("-v", "--verbose", action="count", help="verbose mode")
    parser.add_argument("-b", "--benchmarkPath", type=str, help="path to the benchmark to execute") #make that a mandatory argument
    parser.add_argument("-p", "--patternsBasePath", type=str, help="path to the extracted gate level patterns base pickle file") #make that a mandatory argument
    parser.add_argument("-o", "--outputPath", type=str, help="path to the output directory that will contain the output pickle files") #make that a mandatory argument
    args = parser.parse_args()

    #format arguments
    verbosity = 0
    if args.verbose is not None:
        verbosity = args.verbose

    benchmarkPath = args.benchmarkPath
    outputPath = args.outputPath
    patternsPath = args.patternsBasePath

    #prepare the injection runs
    results_bitwise = {}
    random.seed()
    initResults(results_bitwise)
    referenceCycles, runTime = doGoldenRun(benchmarkPath, verbosity)

    #compute the number of injections needed for 99.8% accuracy and 1% error margin
    recommendedInjCount = getNumberOfNeededRuns(referenceCycles, ri.getTotalWidth())
    if args.nbInj:
        nbInj = args.nbInj
    else :
        nbInj = recommendedInjCount
        print('Default 99.8% confidence, 1% error margin -> {0} injections'.format(nbInj))

    #load the patterns histograms
    patterns = pickle.load(open(patternsPath, 'rb'))
    #normalize the pattern histograms
    ri.unifyPatternProbas(patterns)

    pool = Pool()

    if verbosity > 1:
        print("Error free cycle count : " + str(referenceCycles))
        print("Golden run execution time : " + str(runTime) + "s")
        print("---------------------------------")

    #make the thing partial
    doInjectionPartial = partial(doInjectionRun, benchmarkPath=benchmarkPath, referenceCycles=referenceCycles, patterns=patterns, verbosity=verbosity)
    resultIterator = pool.imap_unordered(doInjectionPartial, range(nbInj))

    ##Merge the result dicts to the main one
    results_runwise = []
    for res in resultIterator:
        place = list(res.keys())[0]
        firstBit = True
        for bit in res[place]:
            results_bitwise[place][bit]['nbInj'] += 1
            results_bitwise[place][bit]['cycles'].append(res[place][bit].cycle)
            results_bitwise[place][bit]['runNumber'].append(res[place][bit].runNumber)
            results_bitwise[place][bit][res[place][bit].endType] += 1
            if firstBit:
                #log per run
                results_runwise.append([place, res[place][bit].endType])
                firstBit = False

    showFinalStats_runwise(results_runwise)

    print("Creating output files")
    saveResults(outputPath, results_bitwise, results_runwise)

if __name__ == "__main__":
    # execute only if run as a script
    main()
