#!/usr/bin/env python3

import subprocess, re, os, random, filecmp, argparse, colorama, collections, pickle, time, pdb, math
from multiprocessing import Pool
from functools import partial
import numpy as np

import FIRegInfo as ri  #register informations and useful functions

#nBitPerInj = 5

PartialResult = collections.namedtuple('PartialResult', ['endType', 'pattern', 'injectionCycle', 'runNumber', 'execCyclesDiff', 'injInstr', 'injPC'])

################################################################################
#               Injection support
################################################################################

#runs the simulator with the given workload and arguments
def executeSimulation(workload, arguments):
    devnull = open(os.devnull, 'w')
    runList = ['../cometFI.sim', '-f', workload]
    runList.extend(arguments)
    #print(' '.join(runList))
    #result = subprocess.run(['../cometFI.sim', '-f', workload] + arguments, stdout=subprocess.PIPE, stderr=devnull)
    result = subprocess.run(runList, stdout=subprocess.PIPE, stderr=devnull)
    devnull.close()
    return result.stdout.decode('unicode_escape')


#collect the golden sample data : execution cycle count, stdout and memory+register dump
def doGoldenRun(benchmarkPath, verbosity):
    startTime = time.time()
    runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/goldenSampleStdout', '-D', '/tmp/goldenSampleMemory'])
    elapsedTime = time.time() - startTime
    #get the cycle count
    cycles = re.findall('in (.*) cycles', runStdOut)
    cycles = int(cycles[0])
    if verbosity > 1:
        print("----------golden stdout----------")
        subprocess.call(['cat', '/tmp/goldenSampleStdout'])
    return cycles, elapsedTime


#injects a fault at the given cycle, checks the workload termination type and populate the result base
def doInjectionRun(runNumber, benchmarkPath, referenceCycles, patterns, verbosity):
    #compute the maximum cycle count
    maxAllowedCycles = 8*referenceCycles

    #pick a cycle
    injectionCycle = random.randint(0, referenceCycles)

    #select a zone to inject in
    place = ri.selectRegion()
    #populate patternToInject as empty
    patternToInject = ''

    if place=='sequential': #choose a random FF and flip it
        #choose a register
        place = ri.selectRegister() #only place where the PC can be hit
        #select a random FF inside
        bitPositions = ri.getrandomBitsinRegister(place, 1)

    elif place == 'comb_other': #inject in one of the core ctrl FFs
        place = 'CoreCtrl'
        bitPositions = ri.getrandomBitsinRegister(place, 1)

    elif place == 'WriteBack':   #inject in the register file
        #see faultInjection.md for further details on the fault model
        #select a random register (can be the one selected in the WB stage)
        place = ri.selectRFRegister()
        #fill it with a random number of errors
        #bitPositions = ri.getrandomBitsinRegister(place, random.randint(1,31))
        bitPositions = ri.getrandomBitsinRegister(place, 1)

    else:  #selected region is a pipeline stage's combinational logic
        patternToInject = ri.getPattern(place, patterns)
        bitPositions = ri.patternToBitPositions(patternToInject)   #select a pattern to inject


    if verbosity > 0:
        print("Injection cycle : " + str(injectionCycle) + ", place : " + place + ", bitPositions : " + ' ' + '"' + ' '.join(map(str, bitPositions)) + '"')
    placeId = ri.getRegisterID(place)
    #run the simulator
    runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/injectionRunStdout_'+str(runNumber), '-D', '/tmp/injectionRunMemory_'+str(runNumber), '-I', str(maxAllowedCycles), str(injectionCycle), str(placeId), ' '.join(map(str, bitPositions))])
    #capture the end type
    endType = re.findall('EndType : (.*)', runStdOut)
    #capture the number of executed cycles
    execCycles = re.findall('Successfully executed .* in (.*) cycles', runStdOut)
    #capture the instruction that was concerned by the injection
    injInstr = re.findall('Instr. at inj cycle: (.*)', runStdOut)
    #capture the pc associated to the corrupted instruction
    injPC = re.findall('PC at inj cycle: (.*)', runStdOut)

    # print(execCycles)
    if (endType[0] == 'Hang') or (endType[0] == 'Crash'):
        cyclesDiff = 'not applicable'
    else:
        cyclesDiff = int(execCycles[0]) - referenceCycles

    #declare the result dict
    resDict = {place : dict(dict())}

    #if the workload execution terminated without a crash or a hang
    if endType[0] == 'Normal':
        #check the output and the memory dump against the golden sample
        filecmp.clear_cache()
        inISMSpace = not filecmp.cmp('/tmp/goldenSampleMemory', '/tmp/injectionRunMemory_'+str(runNumber), shallow=False)
        inAOMSpace = not filecmp.cmp('/tmp/goldenSampleStdout', '/tmp/injectionRunStdout_'+str(runNumber), shallow=False)

        if (inISMSpace) and (inAOMSpace):
            endType[0] = 'ISM & AOM'
        elif (inISMSpace) and (not inAOMSpace):
            endType[0] = 'ISM'
        elif (not inISMSpace) and (inAOMSpace):
            endType[0] = 'AOM'
        else:
            endType[0] = 'Masked'

    if os.path.isfile('/tmp/injectionRunMemory_'+str(runNumber)):
        os.remove('/tmp/injectionRunMemory_'+str(runNumber))
    if os.path.isfile('/tmp/injectionRunStdout_'+str(runNumber)):
        os.remove('/tmp/injectionRunStdout_'+str(runNumber))

    if verbosity > 0:
        print("endType : " + endType[0])

    for bit in bitPositions:
        nt = PartialResult(endType[0], patternToInject, injectionCycle, runNumber, cyclesDiff, injInstr, injPC)
        resDict[place][bit] = nt

    if verbosity > 1:
        print("Run output :")
        subprocess.call(['cat', '/tmp/injectionRunStdout'])
    if verbosity > 0:
        print("---------------------------------")

    return resDict


################################################################################
#               Results support
################################################################################

#sets up all the results data (creates an entry for each bit in the design and initializes it's stats)
def initResults(dic):
    for key in ri.getRegisterList():
        dic[key] = []
        for bit in range(ri.getRegisterWidth(key)):
            dic[key].append({}) #create a dict for each bit in the selected place
            dic[key][bit]["cycles"] =  []
            dic[key][bit]["runNumber"] = []
            dic[key][bit]["execCyclesDiff"] = []
            dic[key][bit]["nbInj"] = 0  #init the selected bit's stats
            dic[key][bit]["Masked"] = 0
            dic[key][bit]["ISM"] = 0
            dic[key][bit]["AOM"] = 0
            dic[key][bit]["ISM & AOM"] = 0
            dic[key][bit]["Hang"] = 0
            dic[key][bit]["Crash"] = 0

def showFinalStats_bitwise(results):
    #go through the results base and collect the needed stats
    sumMasked = 0
    sumISM = 0
    sumAOM = 0
    sumISMAOM = 0
    sumHang = 0
    sumCrash = 0
    for key in ri.getRegisterList():
        for bit in range(ri.getRegisterWidth(key)):
            sumMasked += results[key][bit]["Masked"]
            sumISM += results[key][bit]["ISM"]
            sumAOM += results[key][bit]["AOM"]
            sumISMAOM += results[key][bit]["ISM & AOM"]
            sumHang += results[key][bit]["Hang"]
            sumCrash += results[key][bit]["Crash"]
    print("Masked : " + str(sumMasked))
    print("ISM : " + str(sumISM))
    print("AOM : " + str(sumAOM))
    print("ISM & AOM : " + str(sumISMAOM))
    print("Hang : " + str(sumHang))
    print("Crash : " + str(sumCrash))

def showFinalStats_runwise(results):
    #go through the results base and collect the needed stats
    place_counters = {}
    end_counters = {}

    for run in results:
        #log places
        if run[0] not in place_counters:
            place_counters[run[0]] = 1
        else:
            place_counters[run[0]] += 1
        #log outcomes
        if run[1] not in end_counters:
            end_counters[run[1]] = 1
        else:
            end_counters[run[1]] += 1

    #display the counters
    print('\nInjection spots :')
    for place in place_counters:
        print('{0} : {1}'.format(place, place_counters[place]))
    print('\nInjection results :')
    for end in end_counters:
        print('{0} : {1}'.format(end, end_counters[end]))


def saveResults(path, results_bitwise, results_runwise):
    if os.path.isdir(path):
        #output the results
        with open(path+'/bitwise.pkl', 'wb') as of:
            pickle.dump(results_bitwise, of)
        with open(path+'/runwise.pkl', 'wb') as of:
            pickle.dump(results_runwise, of)

    else: #path doesn't exist, create the directory and output the results
        try:
            os.mkdir(path)
        except OSError:
            print ("Output directory ({0}) creation has failed".format(path))
        with open(path+'/bitwise.pkl', 'wb') as of:
            pickle.dump(results_bitwise, of)
        with open(path+'/runwise.pkl', 'wb') as of:
            pickle.dump(results_runwise, of)

def getNumberOfNeededRuns(workloadCycles, numberOfInjectionPoints):
    #N = workloadCycles*numberOfInjectionPoints
    #div = 1+( ((0.01**2)*(N-1)) / (0.25*(3.0902**2)) )
    #return math.ceil(N/div)
    # Considering infinite population
    return math.ceil((0.25*(3.0902**2))/(0.01**2))



################################################################################
#               Main
################################################################################

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--nbInj", type=int, help="number of injections to perform")
    parser.add_argument("-v", "--verbose", action="count", help="verbose mode")
    parser.add_argument("-b", "--benchmarkPath", type=str, help="path to the benchmark to execute") #make that a mandatory argument
    parser.add_argument("-p", "--patternsBasePath", type=str, help="path to the extracted gate level patterns base pickle file") #make that a mandatory argument
    parser.add_argument("-o", "--outputPath", type=str, help="path to the output directory that will contain the output pickle files") #make that a mandatory argument
    args = parser.parse_args()

    #format arguments
    verbosity = 0
    if args.verbose is not None:
        verbosity = args.verbose

    benchmarkPath = args.benchmarkPath
    outputPath = args.outputPath
    patternsPath = args.patternsBasePath

    #prepare the injection runs
    results_bitwise = {}
    random.seed()
    initResults(results_bitwise)
    referenceCycles, runTime = doGoldenRun(benchmarkPath, verbosity)

    #compute the number of injections needed for 99.8% accuracy and 1% error margin
    recommendedInjCount = getNumberOfNeededRuns(referenceCycles, ri.getTotalWidth())
    if args.nbInj:
        nbInj = args.nbInj
    else :
        nbInj = recommendedInjCount
        print('Default 99.8% confidence, 1% error margin -> {0} injections'.format(nbInj))

    #load the patterns histograms
    patterns = pickle.load(open(patternsPath, 'rb'))
    #normalize the pattern histograms
    ri.unifyPatternProbas(patterns)
    pool = Pool()

    if verbosity > 1:
        print("Error free cycle count : " + str(referenceCycles))
        print("Golden run execution time : " + str(runTime) + "s")
        print("---------------------------------")

    #make the thing partial
    doInjectionPartial = partial(doInjectionRun, benchmarkPath=benchmarkPath, referenceCycles=referenceCycles, patterns=patterns, verbosity=verbosity)
    resultIterator = pool.imap_unordered(doInjectionPartial, range(nbInj))

    ##Merge the result dicts to the main one
    #PartialResult = collections.namedtuple('PartialResult', ['endType', 'pattern', 'injectionCycle', 'runNumber', 'execCyclesDiff', 'injInstr', 'injPC'])
    results_runwise = []
    for res in resultIterator:
        place = list(res.keys())[0]
        firstBit = True
        for bit in res[place]:
            #populate the bitwise database
            # results_bitwise[place][bit]['nbInj'] += 1
            # results_bitwise[place][bit]['injCycle'].append(res[place][bit].injectionCycle)
            # results_bitwise[place][bit]['runNumber'].append(res[place][bit].runNumber)
            # results_bitwise[place][bit]['injInstr'].append(res[place][bit].injInstr)
            # results_bitwise[place][bit][res[place][bit].endType] += 1
            #populate the runwise database
            if firstBit:
                results_runwise.append([place, res[place][bit].endType, res[place][bit].pattern, res[place][bit].injectionCycle, res[place][bit].runNumber, res[place][bit].execCyclesDiff, res[place][bit].injInstr, res[place][bit].injPC])
                firstBit = False

    showFinalStats_runwise(results_runwise)

    print("Creating output files")
    saveResults(outputPath, results_bitwise, results_runwise)

if __name__ == "__main__":
    # execute only if run as a script
    main()
