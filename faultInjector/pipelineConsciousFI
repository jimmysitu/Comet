#!/usr/bin/env python3

import subprocess, re, os, random, filecmp, argparse, colorama, collections, pickle, time
from multiprocessing import Pool
from functools import partial
import numpy as np

import FIRegInfo as ri  #register informations and useful functions

PartialResult = collections.namedtuple('PartialResult', ['endType', 'cycle', 'runNumber'])

################################################################################
#               Injection support
################################################################################

#runs the simulator with the given workload and arguments
def executeSimulation(workload, arguments):
    devnull = open(os.devnull, 'w')
    result = subprocess.run(['../cometFI.sim', '-f', workload] + arguments, stdout=subprocess.PIPE, stderr=devnull)
    devnull.close()
    return result.stdout.decode('unicode_escape')


#collect the golden sample data : execution cycle count, stdout and memory+register dump
def doGoldenRun(benchmarkPath, verbosity):
    startTime = time.time()
    runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/goldenSampleStdout', '-D', '/tmp/goldenSampleMemory'])
    elapsedTime = time.time() - startTime
    #get the cycle count
    cycles = re.findall('in (.*) cycles', runStdOut)
    cycles = int(cycles[0])
    if verbosity > 1:
        print("----------golden stdout----------")
        subprocess.call(['cat', '/tmp/goldenSampleStdout'])
    return cycles, elapsedTime


#injects a fault at the given cycle, checks the workload termination type and populate the result base
def doInjectionRun(runNumber, benchmarkPath, referenceCycles, patterns, verbosity):
    #compute the maximum cycle count
    maxAllowedCycles = 8*referenceCycles

    #pick a cycle
    injectionCycle = random.randint(0, referenceCycles)

    #select a zone to inject in
    place = ri.selectRegion()

    if place=='sequential': #choose a random FF and flip it
        #choose a register
        place = ri.selectRegister() #only place where the PC can be hit
        #select a random FF inside
        bitPositions = ri.getrandomBitsinRegister(place, 1)

    elif place == 'comb_other': #inject in one of the core ctrl FFs
        place = 'CoreCtrl'
        bitPositions = ri.getrandomBitsinRegister(place, 1)

    elif place == 'WriteBack':   #inject in the register file
        #see faultInjection.md for further details on the fault model
        #select a random register (can be the one selected in the WB stage)
        place = ri.selectRFRegister()
        #fill it with a random number of errors
        bitPositions = ri.getrandomBitsinRegister(place, random.randint(1,31))

    else:  #selected region is a pipeline stage's combinational logic
        bitPositions = ri.patternToBitPositions(ri.getPattern(place, patterns))   #select a pattern to inject


    if verbosity > 0:
        print("Injection cycle : " + str(injectionCycle) + ", place : " + place + ", bitPositions : " + ' ' + '"' + ' '.join(map(str, bitPositions)) + '"')
    #run the simulator
    placeId = ri.getRegisterID(place)
    runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/injectionRunStdout', '-D', '/tmp/injectionRunMemory', '-I', str(maxAllowedCycles), str(injectionCycle), str(placeId), '"' + ' '.join(map(str, bitPositions)) + '"'])
    #capture the end type
    endType = re.findall('EndType : (.*)', runStdOut)

    #declare the result dict
    resDict = {place : dict(dict())}

    #if the workload execution terminated without a crash or a hang
    if endType[0] == 'Normal':
        #check the output and the memory dump against the golden sample
        filecmp.clear_cache()   #really needed ?
        inISMSpace = not filecmp.cmp('/tmp/goldenSampleMemory', '/tmp/injectionRunMemory', False)
        inAOMSpace = not filecmp.cmp('/tmp/goldenSampleStdout', '/tmp/injectionRunStdout', False)

        if (inISMSpace) and (inAOMSpace):
            endType[0] = 'ISM & AOM'
        elif (inISMSpace) and (not inAOMSpace):
            endType[0] = 'ISM'
        elif (not inISMSpace) and (inAOMSpace):
            endType[0] = 'AOM'
        else:
            endType[0] = 'Masked'

    if verbosity > 0:
        print("endType : " + endType[0])

    for bit in bitPositions:
        nt = PartialResult(endType[0], injectionCycle, runNumber)
        resDict[place][bit] = nt

    if verbosity > 1:
        print("Run output :")
        subprocess.call(['cat', '/tmp/injectionRunStdout'])
    if verbosity > 0:
        print("---------------------------------")

    return resDict


################################################################################
#               Results support
################################################################################

#sets up all the results data (creates an entry for each bit in the design and initializes it's stats)
def initResults(dic):
    for key in ri.getRegisterList():
        dic[key] = []
        for bit in range(ri.getRegisterWidth(key)):
            dic[key].append({}) #create a dict for each bit in the selected place
            dic[key][bit]["cycles"] =  []
            dic[key][bit]["runNumber"] = []
            dic[key][bit]["nbInj"] = 0  #init the selected bit's stats
            dic[key][bit]["Masked"] = 0
            dic[key][bit]["ISM"] = 0
            dic[key][bit]["AOM"] = 0
            dic[key][bit]["ISM & AOM"] = 0
            dic[key][bit]["Hang"] = 0
            dic[key][bit]["Crash"] = 0

def showFinalStats(results):
    #go through the results base and collect the needed stats
    sumMasked = 0
    sumISM = 0
    sumAOM = 0
    sumISMAOM = 0
    sumHang = 0
    sumCrash = 0
    for key in ri.getRegisterList():
        for bit in range(ri.getRegisterWidth(key)):
            sumMasked += results[key][bit]["Masked"]
            sumISM += results[key][bit]["ISM"]
            sumAOM += results[key][bit]["AOM"]
            sumISMAOM += results[key][bit]["ISM & AOM"]
            sumHang += results[key][bit]["Hang"]
            sumCrash += results[key][bit]["Crash"]
    print("Masked : " + str(sumMasked))
    print("ISM : " + str(sumISM))
    print("AOM : " + str(sumAOM))
    print("ISM & AOM : " + str(sumISMAOM))
    print("Hang : " + str(sumHang))
    print("Crash : " + str(sumCrash))


def saveResults(filename, results):
    with open(filename, 'wb') as of:
        pickle.dump(results, of)

################################################################################
#               Main
################################################################################

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("nbInj", type=int, help="number of injections to perform")
    parser.add_argument("-v", "--verbose", action="count", help="verbose mode")
    parser.add_argument("-b", "--benchmarkPath", type=str, help="path to the benchmark to execute") #make that a mandatory argument
    parser.add_argument("-p", "--patternsBasePath", type=str, help="path to the extracted gate level patterns base pickle file") #make that a mandatory argument
    parser.add_argument("-o", "--outputPath", type=str, help="path to the output pickle file") #make that a mandatory argument
    args = parser.parse_args()

    #format arguments
    verbosity = 0
    if args.verbose is not None:
        verbosity = args.verbose

    benchmarkPath = args.benchmarkPath
    outputPath = args.outputPath
    patternsPath = args.patternsBasePath

    #prepare the injection runs
    results = {}
    random.seed()
    initResults(results)
    referenceCycles, runTime = doGoldenRun(benchmarkPath, verbosity)


    #load the patterns histograms
    patterns = pickle.load(open(patternsPath, 'rb'))
    #normalize the pattern histograms
    ri.unifyPatternProbas(patterns)

    pool = Pool()

    if verbosity > 1:
        print("Error free cycle count : " + str(referenceCycles))
        print("Golden run execution time : " + str(runTime) + "s, estimated injection time : " + str(args.nbInj*runTime) + "s")
        print("---------------------------------")

    #make the fucking thing partial
    doInjectionPartial = partial(doInjectionRun, benchmarkPath=benchmarkPath, referenceCycles=referenceCycles, patterns=patterns, verbosity=verbosity)
    resultIterator = pool.imap_unordered(doInjectionPartial, range(args.nbInj))

    ##Merge the result dicts to the main one
    for res in resultIterator:
        place = list(res.keys())[0]
        for bit in res[place]:
            results[place][bit]['nbInj'] += 1
            results[place][bit]['cycles'].append(res[place][bit].cycle)
            results[place][bit]['runNumber'].append(res[place][bit].runNumber)
            results[place][bit][res[place][bit].endType] += 1

    showFinalStats(results)

    print("Creating output file")
    saveResults(outputPath, results)

if __name__ == "__main__":
    # execute only if run as a script
    main()
