#!/usr/bin/env python3

import subprocess, re, os, random, filecmp, argparse, collections, pickle, time
import numpy as np
import pandas as pd

results = {}

################################################################################
#               input file parsing etc...
################################################################################
def openDatafile(filename):
    dfile = pd.read_excel(filename, sheet_name=None)
    return dfile


################################################################################
#               Injection support
################################################################################


#count the total number of bits we can use as injection points
def getTotalNumberOfBits(regInfo):
    sum = 0
    for reg in regInfo:
        sum += regInfo[reg]['register width'][0]
    return int(sum)

def unifyProbabilities(regInfo):
    #concatenate all the registers distributions
    overallDistribArray = []
    for reg in regInfo:
        overallDistribArray.extend(regInfo[reg]['Error proba normalized'].tolist())
    #normalize them
    sumVal = sum(overallDistribArray)
    for elt in range(len(overallDistribArray)): #Could be done in a much much nicer way
        overallDistribArray[elt] = overallDistribArray[elt]/sumVal
    return overallDistribArray


def getBitLocation(regInfo, bitNumber):
    sum = 0
    for reg in regInfo:
        if (bitNumber >= sum) and (bitNumber < sum + regInfo[reg]['register width'][0]):    #On the right register
            return (reg, int(bitNumber-sum))
        else:
            sum += regInfo[reg]['register width'][0]
    print("Bit #" + str(bitNumber) + " not found !")

#runs the simulator with the given workload and arguments
def executeSimulation(workload, arguments):
    devnull = open(os.devnull, 'w')
    result = subprocess.run(['../cometFI.sim', '-f', workload] + arguments, stdout=subprocess.PIPE, stderr=devnull)
    devnull.close()
    return result.stdout.decode('unicode_escape')

#collect the golden sample data : execution cycle count, stdout and memory+register dump
def doGoldenRun(benchmarkPath, verbosity):
    startTime = time.time()
    runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/goldenSampleStdout', '-D', '/tmp/goldenSampleMemory'])
    elapsedTime = time.time() - startTime
    #get the cycle count
    cycles = re.findall('in (.*) cycles', runStdOut)
    cycles = int(cycles[0])
    if verbosity > 1:
        print("----------golden stdout----------")
        subprocess.call(['cat', '/tmp/goldenSampleStdout'])
    return cycles, elapsedTime

#injects a fault at the given cycle, checks the workload termination type and populate the result base
def doInjectionRun(regInfo, benchmarkPath, referenceCycles, maxAllowedCycles, verbosity, errorDistrib):
    #pick a cycle
    injectionCycle = random.randint(0, referenceCycles)

    #pick a bit between 0 and TotalNumberOfBits-1
    bitNumber = np.random.choice(range(getTotalNumberOfBits(regInfo)), p=errorDistrib)
    place, bitPosition = getBitLocation(regInfo, bitNumber)
    placeId = int(regInfo[place]['register id'][0])

    if verbosity > 0:
        print("Injection cycle : " + str(injectionCycle) + ", place : " + place + ", placeId : " + str(placeId) + ", bitPosition : " + str(bitPosition) + ", Bit Number : " + str(bitNumber))
    #run the simulator
    runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/injectionRunStdout', '-D', '/tmp/injectionRunMemory', '-I', str(maxAllowedCycles), str(injectionCycle), str(placeId), str(bitPosition)])
    #capture the end type
    endType = re.findall('EndType : (.*)', runStdOut)

    #if the workload execution terminated without a crash or a hang
    if endType[0] == 'Normal':
        #check the output and the memory dump against the golden sample
        filecmp.clear_cache()   #really needed ?
        inISMSpace = not filecmp.cmp('/tmp/goldenSampleMemory', '/tmp/injectionRunMemory', False)
        inAOMSpace = not filecmp.cmp('/tmp/goldenSampleStdout', '/tmp/injectionRunStdout', False)

        if (inISMSpace) and (inAOMSpace):
            endType[0] = 'ISM & AOM'
        elif (inISMSpace) and (not inAOMSpace):
            endType[0] = 'ISM'
        elif (not inISMSpace) and (inAOMSpace):
            endType[0] = 'AOM'
        else:
            endType[0] = 'Masked'

    if verbosity > 0:
        print("endType : " + endType[0])
    #update results base
    results[place][bitPosition]['nbInj'] += 1
    results[place][bitPosition][endType[0]] += 1
    if verbosity > 1:
        print("Run output :")
        subprocess.call(['cat', '/tmp/injectionRunStdout'])
    if verbosity > 0:
        print("---------------------------------")


################################################################################
#               Results support
################################################################################

#sets up all the results data (creates an entry for each bit in the design and initializes it's stats)
def initResults(regInfo):
    for key in regInfo.keys():
        results[key] = []   #create places entries
        for bit in range(0, int(regInfo[key]['register width'][0])):
            results[key].append({}) #create a dict for each bit in the selected place
            results[key][bit]["nbInj"] = 0  #init the selected bit's stats
            results[key][bit]["Masked"] = 0
            results[key][bit]["ISM"] = 0
            results[key][bit]["AOM"] = 0
            results[key][bit]["ISM & AOM"] = 0
            results[key][bit]["Hang"] = 0
            results[key][bit]["Crash"] = 0

def showFinalStats():
    #go through the results base and collect the needed stats
    sumMasked = 0
    sumISM = 0
    sumAOM = 0
    sumISMAOM = 0
    sumHang = 0
    sumCrash = 0
    for key in results.keys():
        for bit in range(0, len(results[key])):
            sumMasked += results[key][bit]["Masked"]
            sumISM += results[key][bit]["ISM"]
            sumAOM += results[key][bit]["AOM"]
            sumISMAOM += results[key][bit]["ISM & AOM"]
            sumHang += results[key][bit]["Hang"]
            sumCrash += results[key][bit]["Crash"]
    print("Masked : " + str(sumMasked))
    print("ISM : " + str(sumISM))
    print("AOM : " + str(sumAOM))
    print("ISM & AOM : " + str(sumISMAOM))
    print("Hang : " + str(sumHang))
    print("Crash : " + str(sumCrash))


def saveResults(filename):
    with open(filename, 'wb') as of:
        pickle.dump(results, of)

################################################################################
#               Main
################################################################################

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("nbInj", type=int, help="number of injections to perform")
    parser.add_argument("-v", "--verbose", action="count", help="verbose mode")
    parser.add_argument("-b", "--benchmarkPath", type=str, help="path to the benchmark to execute") #make that a mandatory argument
    parser.add_argument("-o", "--outputPath", type=str, help="path to the output csv file") #make that a mandatory argument
    parser.add_argument("-d", "--distributionPath", type=str, help="path to the register probability distribution file") #make that a mandatory argument
    args = parser.parse_args()

    #format arguments
    verbosity = 0
    if args.verbose is not None:
        verbosity = args.verbose

    benchmarkPath = args.benchmarkPath
    outputPath = args.outputPath

    #prepare the injeciton runs
    random.seed()
    regInfo = openDatafile(args.distributionPath)
    overallProba = unifyProbabilities(regInfo)
    initResults(regInfo)
    referenceCycles, runTime = doGoldenRun(benchmarkPath, verbosity)
    maxCycles = 8*referenceCycles


    if verbosity > 1:
        print("Error free cycle count : " + str(referenceCycles) + ", maxCycles : " + str(maxCycles))
        print("Golden run execution time : " + str(runTime) + "s, estimated injection time : " + str(args.nbInj*runTime) + "s")
        print("---------------------------------")

    for i in range(args.nbInj):
        if verbosity > 0:
            print(str(i+1) + '/' + str(args.nbInj) + " :")
        doInjectionRun(regInfo, benchmarkPath, referenceCycles, maxCycles, verbosity, overallProba)

    showFinalStats()

    print("Creating output file")
    saveResults(outputPath)

if __name__ == "__main__":
    # execute only if run as a script
    main()
