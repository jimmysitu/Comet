#!/usr/bin/env python3

import subprocess, re, os, random, filecmp, argparse, colorama

benchmarkPath = '../benchmarks/build/matmul_int_4.riscv32'

'''
places = {'FToDC':[0, 97], 'DCToEx':[1, 174], 'ExToMem':[2, 126], 'MemToWB':[3, 115], 'PC':[4, 32], 'RF0':[5, 32],
'RF1':[6, 32], 'RF2':[7, 32], 'RF3':[8, 32], 'RF4':[9, 32], 'RF5':[10, 32], 'RF6':[11, 32], 'RF7':[12, 32], 'RF8':[13, 32],
'RF9':[14, 32], 'RF10':[15, 32], 'RF11':[16, 32], 'RF12':[17, 32], 'RF13':[18, 32], 'RF14':[19, 32], 'RF15':[20, 32],
'RF16':[21, 32], 'RF17':[22, 32], 'RF18':[23, 32], 'RF19':[24, 32], 'RF20':[25, 32], 'RF21':[26, 32], 'RF22':[27, 32],
'RF23':[28, 32], 'RF24':[29, 32], 'RF25':[30, 32], 'RF26':[31, 32], 'RF27':[32, 32], 'RF28':[33, 32], 'RF29':[34, 32],
'RF30':[35, 32], 'RF31':[36, 32], 'CoreCtrl':[37, 205]}
'''

places = {'FToDC':[0, 97], 'DCToEx':[1, 174], 'ExToMem':[2, 126], 'MemToWB':[3, 115], 'PC':[4, 32], 'CoreCtrl':[37, 205]}


results = {}

#sets up all the results data (creates an entry for each bit in the design and initializes it's stats)
def initResults():
    for key in places.keys():
        results[key] = []   #create places entries
        for bit in range(0, places[key][1]):
            results[key].append({}) #create a dict for each bit in the selected place
            results[key][bit]["nbInj"] = 0  #init the selected bit's stats
            results[key][bit]["Masked"] = 0
            results[key][bit]["SDC"] = 0
            results[key][bit]["Hang"] = 0
            results[key][bit]["Crash"] = 0

def executeSimulation(workload, arguments):
    devnull = open(os.devnull, 'w')
    result = subprocess.run(['../cometFI.sim', '-f', workload] + arguments, stdout=subprocess.PIPE, stderr=devnull)
    devnull.close()
    return result.stdout.decode('unicode_escape')

def doGoldenRun(verbose):
    runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/goldenSampleMemory'])
    #get the cycle count
    cycles = re.findall('in (.*) cycles', runStdOut)
    cycles = int(cycles[0])
    if verbose == True:
        subprocess.call(['cat', '/tmp/goldenSampleMemory'])
    return cycles

def doInjectionRun(referenceCycles, maxAllowedCycles, verbose):
    #pick a cycle
    injectionCycle = random.randint(0, referenceCycles)
    #pick a place to inject
    place = random.sample(list(places.items()), 1)
    placeId = place[0][1][0]
    placeName = place[0][0]
    #pick a bit
    bitPosition = random.randint(0, place[0][1][1]-1)
    if verbose == True:
        print("Injection cycle : " + str(injectionCycle) + ", place : " + place[0][0] + ", placeId : " + str(placeId) + ", bitPosition : " + str(bitPosition))
    #run the simulator
    runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/injectionRunMemory', '-I', str(maxAllowedCycles), str(injectionCycle), str(placeId), str(bitPosition)])
    #capture the end type
    endType = re.findall('EndType : (.*)', runStdOut)
    #if necessary check memory contents
    if endType[0] == 'Normal':
        #check difference here
        if filecmp.cmp('/tmp/goldenSampleMemory', '/tmp/injectionRunMemory', False) == False:
            endType[0] = 'SDC'
        else:
            endType[0] = 'Masked'
    if verbose == True:
        print(endType[0])
    #update results base
    results[placeName][bitPosition]['nbInj'] += 1
    results[placeName][bitPosition][endType[0]] += 1
    if verbose == True:
        subprocess.call(['cat', '/tmp/injectionRunMemory'])
    if verbose == True:
        print("------------------------")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("nbInj", type=int, help="number of injections to perform")
    parser.add_argument("-v", "--verbose", action="store_true", help="verbose mode")
    args = parser.parse_args()

    #prepare the injeciton runs
    random.seed()
    initResults()
    referenceCycles = doGoldenRun(args.verbose)
    maxCycles = 8*referenceCycles
    if args.verbose == True:
        print("Normal cycles : " + str(referenceCycles) + ", maxCycles : " + str(maxCycles))
    for i in range(args.nbInj):
        doInjectionRun(referenceCycles, maxCycles, args.verbose)
        if args.verbose == True:
            print(str(i+1) + '/' + str(args.nbInj))

    #go through the results base and collect the needed stats
    sumMasked = 0
    sumSDC = 0
    sumHang = 0
    sumCrash = 0
    for key in places.keys():
        for bit in range(0, places[key][1]):
            sumMasked += results[key][bit]["Masked"]
            sumSDC += results[key][bit]["SDC"]
            sumHang += results[key][bit]["Hang"]
            sumCrash += results[key][bit]["Crash"]
    print("Masked : " + str(sumMasked))
    print("SDC : " + str(sumSDC))
    print("Hang : " + str(sumHang))
    print("Crash : " + str(sumCrash))

if __name__ == "__main__":
    # execute only if run as a script
    main()
