#!/usr/bin/env python3

import subprocess, re, os, random, filecmp, argparse, colorama, collections

#benchmarkPath = '../benchmarks/build/qsort_short_100.riscv32'

places = collections.OrderedDict({'FToDC':[0, 97], 'DCToEx':[1, 174], 'ExToMem':[2, 126], 'MemToWB':[3, 115], 'PC':[4, 32], 'RF0':[5, 32],
'RF1':[6, 32], 'RF2':[7, 32], 'RF3':[8, 32], 'RF4':[9, 32], 'RF5':[10, 32], 'RF6':[11, 32], 'RF7':[12, 32], 'RF8':[13, 32],
'RF9':[14, 32], 'RF10':[15, 32], 'RF11':[16, 32], 'RF12':[17, 32], 'RF13':[18, 32], 'RF14':[19, 32], 'RF15':[20, 32],
'RF16':[21, 32], 'RF17':[22, 32], 'RF18':[23, 32], 'RF19':[24, 32], 'RF20':[25, 32], 'RF21':[26, 32], 'RF22':[27, 32],
'RF23':[28, 32], 'RF24':[29, 32], 'RF25':[30, 32], 'RF26':[31, 32], 'RF27':[32, 32], 'RF28':[33, 32], 'RF29':[34, 32],
'RF30':[35, 32], 'RF31':[36, 32], 'CoreCtrl':[37, 205]})

'''
places = {'FToDC':[0, 97], 'DCToEx':[1, 174], 'ExToMem':[2, 126], 'MemToWB':[3, 115], 'PC':[4, 32], 'CoreCtrl':[37, 205]}
'''

results = {}

#sets up all the results data (creates an entry for each bit in the design and initializes it's stats)
def initResults():
    for key in places.keys():
        results[key] = []   #create places entries
        for bit in range(0, places[key][1]):
            results[key].append({}) #create a dict for each bit in the selected place
            results[key][bit]["nbInj"] = 0  #init the selected bit's stats
            results[key][bit]["Masked"] = 0
            results[key][bit]["ISM"] = 0
            results[key][bit]["AOM"] = 0
            results[key][bit]['ISM & AOM'] = 0
            results[key][bit]["Hang"] = 0
            results[key][bit]["Crash"] = 0

#count the total number of bits we can use as injection points
def getTotalNumberOfBits():
    sum = 0
    for key in places.keys():
        sum += places[key][1]
    return sum


def getBitLocation(bitNumber):
    sum = 0
    for key in places.keys():
        if (bitNumber >= sum) and (bitNumber < sum + places[key][1]):    #we're on the right register
            return (key, bitNumber-sum)
        else:
            sum += places[key][1]
    print("Bit #" + str(bitNumber) + " not found !")

#runs the simulator with the given workload and arguments
def executeSimulation(workload, arguments):
    devnull = open(os.devnull, 'w')
    result = subprocess.run(['../cometFI.sim', '-f', workload] + arguments, stdout=subprocess.PIPE, stderr=devnull)
    devnull.close()
    return result.stdout.decode('unicode_escape')

#collect the golden sample data : execution cycle count, stdout and memory+register dump
def doGoldenRun(benchmarkPath, verbosity):
    runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/goldenSampleStdout', '-D', '/tmp/goldenSampleMemory'])
    #get the cycle count
    cycles = re.findall('in (.*) cycles', runStdOut)
    cycles = int(cycles[0])
    if verbosity > 1:
        print("----------golden stdout----------")
        subprocess.call(['cat', '/tmp/goldenSampleStdout'])
        print("---------------------------------")
    return cycles

#injects a fault at the given cycle, checks the workload termination type and populate the result base
def doInjectionRun(benchmarkPath, referenceCycles, maxAllowedCycles, verbosity):
    #pick a cycle
    injectionCycle = random.randint(0, referenceCycles)

    #pick a bit between 0 and TotalNumberOfBits-1
    bitNumber = random.randint(0, getTotalNumberOfBits()-1)
    place, bitPosition = getBitLocation(bitNumber)
    placeId = places[place][0]

    if verbosity > 0:
        print("Injection cycle : " + str(injectionCycle) + ", place : " + place + ", placeId : " + str(placeId) + ", bitPosition : " + str(bitPosition) + ", Bit Number : " + str(bitNumber))
    #run the simulator
    runStdOut = executeSimulation(benchmarkPath, ['-o', '/tmp/injectionRunStdout', '-D', '/tmp/injectionRunMemory', '-I', str(maxAllowedCycles), str(injectionCycle), str(placeId), str(bitPosition)])
    #capture the end type
    endType = re.findall('EndType : (.*)', runStdOut)

    #if the workload execution terminated without a crash or a hang
    if endType[0] == 'Normal':
        #check the output and the memory dump against the golden sample
        filecmp.clear_cache()   #really needed ?
        inISMSpace = not filecmp.cmp('/tmp/goldenSampleMemory', '/tmp/injectionRunMemory', False)
        inAOMSpace = not filecmp.cmp('/tmp/goldenSampleStdout', '/tmp/injectionRunStdout', False)

        if (inISMSpace) and (inAOMSpace):
            endType[0] = 'ISM & AOM'
        elif (inISMSpace) and (not inAOMSpace):
            endType[0] = 'ISM'
        elif (not inISMSpace) and (inAOMSpace):
            endType[0] = 'AOM'
        else:
            endType[0] = 'Masked'

    if verbosity > 0:
        print("endType : " + endType[0])
    #update results base
    results[place][bitPosition]['nbInj'] += 1
    results[place][bitPosition][endType[0]] += 1
    if verbosity > 1:
        print("Run output :")
        subprocess.call(['cat', '/tmp/injectionRunStdout'])
    if verbosity > 0:
        print("---------------------------------")

def showFinalStats():
    #go through the results base and collect the needed stats
    sumMasked = 0
    sumISM = 0
    sumAOM = 0
    sumISMAOM = 0
    sumHang = 0
    sumCrash = 0
    for key in places.keys():
        for bit in range(0, places[key][1]):
            sumMasked += results[key][bit]["Masked"]
            sumISM += results[key][bit]["ISM"]
            sumAOM += results[key][bit]["AOM"]
            sumISMAOM += results[key][bit]["ISM & AOM"]
            sumHang += results[key][bit]["Hang"]
            sumCrash += results[key][bit]["Crash"]
    print("Masked : " + str(sumMasked))
    print("ISM : " + str(sumISM))
    print("AOM : " + str(sumAOM))
    print("ISM & AOM : " + str(sumISMAOM))
    print("Hang : " + str(sumHang))
    print("Crash : " + str(sumCrash))

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("nbInj", type=int, help="number of injections to perform")
    parser.add_argument("-v", "--verbose", action="count", help="verbose mode")
    parser.add_argument("-b", "--benchmarkPath", type=str, help="path to the benchmark to execute")
    args = parser.parse_args()

    #format arguments
    verbosity = 0
    if args.verbose is not None:
        verbosity = args.verbose

    benchmarkPath = args.benchmarkPath

    #prepare the injeciton runs
    random.seed()
    initResults()
    referenceCycles = doGoldenRun(benchmarkPath, verbosity)
    maxCycles = 8*referenceCycles

    '''
    if args.verbose > 0:
        print("Normal cycles : " + str(referenceCycles) + ", maxCycles : " + str(maxCycles))
    '''
    for i in range(args.nbInj):
        if verbosity > 0:
            print(str(i+1) + '/' + str(args.nbInj) + " :")
        doInjectionRun(benchmarkPath, referenceCycles, maxCycles, verbosity)

    showFinalStats()

if __name__ == "__main__":
    # execute only if run as a script
    main()
